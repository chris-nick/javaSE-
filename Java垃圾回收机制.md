## java垃圾回收机制

  > 首先要知道java中的所有对象实例都是在堆上创建的，常量和静态变量存储在方法区。
  
  > 为了回收，堆又划分为三个区：新生代(Young Generation)、老年代(Tenured/Old Generation)、永久代(Permanent Generation/Perm Area)。
    新生代进一步划分为：Eden区、Survivor1区、Survivor2区。
    
  > 新创建的对象会分配在Eden区，当发生一次Minor GC 就会移到Survivor1区，再发生一次Mino
    GC被移到Survivor2区，直到被移到老年代(某些大对象会直接在老年代分配)。默认经历15次Minor GC还存活的对象就会被移到老年代。
    
  > 为什么要进行回收（GC）？ 清除需要清楚的对象，释放堆内存。
  
  > 回收(GC)的是谁？ 此对象的所有引用都为null,或者循环依赖(ObjA引用ObjB,ObjB引用ObjA，除此之外没有其他引用，那么ObjA和ObjB都需要回收)
  
  > 谁来进行垃圾回收（GC）？ java的回收由jvm来提供，GC由一个被称为垃圾回收器的守护线程执行。这恰恰将程序员解脱出来，程序员只需要处理业   务逻辑。程序开发者不能强制执行GC,GC的执行由堆内存的大小来决定。另外，程序中System.gc()或者Runntime.gc()只是像JVM发了一个GC请求，并   不一定会GC.
  
  > 何时进行回收(GC)？ Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。
    Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。永久代是否执行GC，取决于采用的JVM。
    
  > 发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。
  
  > JVM的参数-Xmx和-Xms用来设置Java堆内存的初始大小和最大值。
  
  > Full GC？并发垃圾回收器的内存回收过程是与用户线程一起并发执行的。通常情况下，并发垃圾回收器可以在用户线程运行的情况下完成大部分的   回收工作，所以应用停顿时间很短。但由于并发垃圾回收时用户线程还在运行，所以会有新的垃圾不断产生。作为担保，如果在老年代内存都被占用   之前，如果并发垃圾回收器还没结束工作，那么应用会暂停，在所有用户线程停止的情况下完成回收。这种情况称作Full GC。由于Full             GC很影响应用的性能，要尽量避免或减少。特别是如果对于高容量低延迟的电商系统，要尽量避免在交易时间段发生Full GC。
  
  > GC算法了解：标记移除算法（效率低，有内存碎片）、复制算法（高效，会浪费一定的内存）、标记整理算法（不会有内存碎片）
  
  > 垃圾回收器的类型：
    原文链接: http://yemengying.com/2016/05/13/jvm-GC/
  
